%{
#include <stdio.h>
#include "parse_utils.h"
#include <iostream>
#include "hw3_output.hpp"
using namespace std;
using namespace output;
extern int yylex();
extern int yylineno;
void yyerror(const char* message);
%}


%token TRUE
%token FALSE
%token RETURN
%token ID
%token NUM
%token VOID
%token INT
%token IF
%token SC
%token BOOL
%token COMMA
%token WHILE
%token BREAK
%token STRING
%token BYTE
%token B
%token CONTINUE
%token AUTO 
%token COLON



%right ASSIGN

%left OR

%left AND

%left EQUAL_UNEQUAL

%nonassoc NOT_EQUALITY

%left ADD
%left SUB

%left MUL 
%left DIV

%right NOT

%left LBRACE
%left RBRACE
%left LPAREN 
%left RPAREN

// highest priority in order to take care of dangaling else

%right ELSE

%%

Program: Funcs
    {}
Funcs:  %empty
    {Utils::instance().pFunctions(yylineno);}
Funcs: FuncDecl Funcs
    {Utils::instance().pFunctions(yylineno);}
FuncDecl: FuncHead LBRACE Statements  RBRACE PopScope  // pushing scope inside FuncHead too
    {Utils::instance().pFunctionDeclaration(yylineno);}
FuncHead: RetType ID LPAREN Formals RPAREN
    {$$ = Utils::instance().parseFunctionDef(yylineno, $1, $2, $4);}
RetType: Type
    {$$ = Utils::instance().pReturnType(yylineno, $1);}
RetType: VOID
    {$$ = Utils::instance().pReturnType(yylineno);}
Formals: %empty
    {$$ = Utils::instance().pFormals(yylineno);}
Formals: FormalsList
    {$$ = Utils::instance().pFormals(yylineno, $1);}
FormalsList: FormalDecl
    {$$ = Utils::instance().pFormList(yylineno, $1);}
FormalsList: FormalDecl COMMA FormalsList
    {$$ = Utils::instance().pFormList(yylineno, $1, $3);}
FormalDecl: Type ID
    {$$ = Utils::instance().ParseFormalDecl(yylineno, $1, $2);}
Statements: Statement
    {Utils::instance().parseState(yylineno);}
Statements: Statements Statement
    {Utils::instance().parseState(yylineno);}
Statement: PushStatementScope LBRACE Statements RBRACE PopScope
    {Utils::instance().parseStateOfState(yylineno);}
Statement: Type ID SC
    {Utils::instance().parseStateType(yylineno, $1, $2);}
Statement: Type ID ASSIGN Exp SC
    {Utils::instance().parseStateTypeAssignment(yylineno, $1, $2, $4);}
Statement: AUTO ID ASSIGN Exp SC
    {Utils::instance().parseStateTypeAssignment(yylineno, $1, $2, $4);}
Statement: ID ASSIGN Exp SC
    {Utils::instance().parseStateAssignment(yylineno, $1, $3);}
Statement: Call SC
    {Utils::instance().parseStateCallFunc(yylineno);}
Statement: RETURN SC
    {Utils::instance().parseStateRet(yylineno);}
Statement: RETURN Exp SC
    {Utils::instance().parseStateRetExpression(yylineno, $2);}
Statement: IF LPAREN Exp CheckBool RPAREN PushStatementScope Statement PopScope
    {Utils::instance().parseStateIf(yylineno);}
Statement: IF LPAREN Exp CheckBool RPAREN PushStatementScope Statement PopScope ELSE PushStatementScope Statement PopScope
    {Utils::instance().parseStateElseIF(yylineno);}
Statement: WHILE LPAREN Exp CheckBool RPAREN PushWhileScope Statement PopScope
    {Utils::instance().parseStatemeWhile(yylineno);}
Statement: BREAK SC
    {Utils::instance().parseStateBreak(yylineno);}
Statement: CONTINUE SC
    {Utils::instance().parseStateContinue(yylineno);}
Call: ID LPAREN ExpList RPAREN
    {$$ = Utils::instance().pCall(yylineno, $1, $3);}
Call: ID LPAREN RPAREN
    {$$ = Utils::instance().pCall(yylineno, $1);}
ExpList: Exp
    {$$ = Utils::instance().pExpressionList(yylineno, $1);}
ExpList: Exp COMMA ExpList
    {$$ = Utils::instance().pExpressionList(yylineno, $1, $3);}
Type: INT
    {$$ = Utils::instance().pInt(yylineno);}
Type: BYTE
    {$$ = Utils::instance().pByte(yylineno);}
Type: BOOL
    {$$ = Utils::instance().pBool(yylineno);}
Exp: LPAREN Exp RPAREN
    {$$ = Utils::instance().pParen(yylineno, $2);}
Exp: Exp ADD Exp
    {$$ = Utils::instance().pBinaryOp(yylineno, $1, $3);}
Exp: Exp SUB Exp
    {$$ = Utils::instance().pBinaryOp(yylineno, $1, $3);}
Exp: Exp MUL Exp
    {$$ = Utils::instance().pBinaryOp(yylineno, $1, $3);}
Exp: Exp DIV Exp
    {$$ = Utils::instance().pBinaryOp(yylineno, $1, $3);}
Exp: ID
    {$$ = Utils::instance().pId(yylineno, $1);}
Exp: Call
    {$$ = Utils::instance().pCallExpression(yylineno, $1);}
Exp: NUM
    {$$ = Utils::instance().pNum(yylineno, $1);}
Exp: NUM B
    {$$ = Utils::instance().pNumB(yylineno, $1);}
Exp: STRING
    {$$ = Utils::instance().pString(yylineno, $1);}
Exp: TRUE
    {$$ = Utils::instance().pTrue(yylineno);}
Exp: FALSE
    {$$ = Utils::instance().pFalse(yylineno);}
Exp: NOT Exp
    {$$ = Utils::instance().pNot(yylineno, $2);}
Exp: Exp AND Exp
    {$$ = Utils::instance().pAnd(yylineno, $1, $3);}
Exp: Exp OR Exp
    {$$ = Utils::instance().pOr(yylineno, $1, $3);}
Exp: Exp EQUAL_UNEQUAL Exp
    {$$ = Utils::instance().pRelOprator(yylineno, $1, $3);}
Exp: Exp NOT_EQUALITY Exp
    {$$ = Utils::instance().pRelOprator(yylineno, $1, $3);}
Exp: LPAREN Type RPAREN Exp
    {$$ = Utils::instance().pCast(yylineno, $2, $4);}
PushStatementScope: %empty
    {Utils::instance().pAddStateScope(yylineno);}
PushWhileScope: %empty
    {Utils::instance().pAddWhileScope(yylineno);}
PopScope: %empty
    {Utils::instance().pPopScope(yylineno);}
CheckBool : %empty
    {Utils::instance().pCheckBool(yylineno, $0);}
%%

void yyerror(const char * message)
{
	errorInSyntax(yylineno);
	exit(0);
}