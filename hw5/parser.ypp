%{
#include "compiler.h"
%}

%token RETURN
%token IF
%token FALSE
%token BOOL
%token COLON
%token BREAK
%token CONTINUE
%token SC
%token WHILE
%token COMMA
%token ID
%token NUM
%token VOID
%token AUTO
%token INT
%token BYTE
%token B
%token STRING
%token DOTS
%token TRUE


%right ASSIGN
%left OR
%left AND
%left EQUAL_UNEQUAL

//%nonassoc NOT_EQUALITY

//%left ADD
//%left SUB
//%left MUL
//%left DIV

// priority 9
%nonassoc INEQUALITY

// priority 11
%left PLUS_MINUS

// priority 12
%left MULT_DIV

%right NOT
%left LBRACKET
%left RBRACKET 
%left LBRACE 
%left RBRACE 
%left LPAREN 
%left RPAREN

%right ELSE
%%

Program: Funcs
    {}
Funcs:  %empty
    {Compiler::instance().pFuncs(yylineno);}
Funcs: FuncDecl Funcs
    {Compiler::instance().pFuncs(yylineno);}
FuncDecl: FuncHead LBRACE Statements GenerateNextLabel RBRACE
    {Compiler::instance().pFuncDecl(yylineno, $3, $4);}
FuncHead: RetType ID LPAREN Formals RPAREN
    {Compiler::instance().pFuncHead(yylineno, $1, $2, $4);}
RetType: Type
    {$$ = Compiler::instance().pRetType(yylineno, $1);}
RetType: VOID
    {$$ = Compiler::instance().pRetType(yylineno);}
Formals: %empty
    {$$ = Compiler::instance().pFs(yylineno);}
Formals: FormalsList
    {$$ = Compiler::instance().pFs(yylineno, $1);}
FormalsList: FormalDecl
    {$$ = Compiler::instance().pFsList(yylineno, $1);}
FormalsList: FormalDecl COMMA FormalsList
    {$$ = Compiler::instance().pFsList(yylineno, $1, $3);}
FormalDecl: Type ID
    {$$ = Compiler::instance().pFDecl(yylineno, $1, $2);}
Statements: Statement BNext
    {$$ = Compiler::instance().pStat(yylineno, $1, $2);}
Statements: Statements BNext GenerateNextLabel Statement BNext
    {$$ = Compiler::instance().pStat(yylineno, $1, $2, $3, $4, $5);}
Statement: PushStatementScope LBRACE Statements RBRACE PopScope
    {$$ = Compiler::instance().pStatOfStats(yylineno, $3);}
Statement: Type ID SC
    {$$ = Compiler::instance().pStatType(yylineno, $1, $2);}
Statement: Type ID ASSIGN Exp SC
    {$$ = Compiler::instance().pStatTypeAssign(yylineno, $1, $2, $4);}
Statement: ID ASSIGN Exp SC
    {$$ = Compiler::instance().pStatAssign(yylineno, $1, $3);}
Statement: Call SC
    {$$ = Compiler::instance().pStatCall(yylineno);}
Statement: RETURN SC
    {$$ = Compiler::instance().pStatRet(yylineno);}
Statement: RETURN Exp SC
    {$$ = Compiler::instance().pStatRetExp(yylineno, $2);}
Statement: IF LPAREN Exp CheckBool RPAREN PushStatementScope GenerateIfLabel Statement PopScope BIfNext
    {$$ = Compiler::instance().pStatIf(yylineno, $3, $7, $8, $10);}
Statement: IF LPAREN Exp CheckBool RPAREN PushStatementScope GenerateIfLabel Statement PopScope BIfNext ELSE PushStatementScope GenerateElseLabel Statement PopScope
    {$$ = Compiler::instance().pStatIfElse(yylineno, $3, $7, $8, $10, $13, $14);}
Statement: WHILE LPAREN BWhileH GenerateWhileHeadLabel Exp CheckBool RPAREN PushWhileScope GenerateWhileBodyLabel Statement BWhileH
    {$$ = Compiler::instance().pStatWhile(yylineno, $3, $4, $5, $9, $10, $11);}
Statement: BREAK SC
    {$$ = Compiler::instance().pStatBreak(yylineno);}
Statement: CONTINUE SC
    {$$ = Compiler::instance().pStatContinue(yylineno);}

Call: ID LPAREN ExpList RPAREN
    {$$ = Compiler::instance().pCall(yylineno, $1, $3);}
Call: ID LPAREN RPAREN
    {$$ = Compiler::instance().pCall(yylineno, $1);}
ExpList: Exp ConvertBool
    {$$ = Compiler::instance().pExplist(yylineno, $2);}
ExpList: Exp ConvertBool COMMA ExpList
    {$$ = Compiler::instance().pExplist(yylineno, $2, $4);}
Type: INT
    {$$ = Compiler::instance().pInt(yylineno);}
Type: BYTE
    {$$ = Compiler::instance().pByte(yylineno);}
Type: BOOL
    {$$ = Compiler::instance().pBool(yylineno);}
Exp: LPAREN Exp RPAREN
    {$$ = Compiler::instance().pParen(yylineno, $2);}
//Exp: Exp SUB  Exp
 //   {$$ = Compiler::instance().pBinop(yylineno, $1, $2, $3);}
//Exp: Exp ADD Exp
//    {$$ = Compiler::instance().pBinop(yylineno, $1, $2, $3);}
//Exp: Exp MUL Exp
//    {$$ = Compiler::instance().pBinop(yylineno, $1, $2, $3);}
//Exp: Exp DIV Exp
 //   {$$ = Compiler::instance().pBinop(yylineno, $1, $2, $3);}
Exp: Exp PLUS_MINUS Exp
    {$$ = Compiler::instance().pBinop(yylineno, $1, $2, $3);}
Exp: Exp MULT_DIV Exp
    {$$ = Compiler::instance().pBinop(yylineno, $1, $2, $3);}
Exp: ID
    {$$ = Compiler::instance().pID(yylineno, $1);}
Exp: Call
    {$$ = Compiler::instance().pCallExp(yylineno, $1);}
Exp: NUM
    {$$ = Compiler::instance().pNum(yylineno, $1);}
Exp: NUM B
    {$$ = Compiler::instance().pNumB(yylineno, $1);}
Exp: STRING
    {$$ = Compiler::instance().pString(yylineno, $1);}
Exp: TRUE
    {$$ = Compiler::instance().pTrue(yylineno);}
Exp: FALSE
    {$$ = Compiler::instance().pFalse(yylineno);}
Exp: NOT Exp
    {$$ = Compiler::instance().pNot(yylineno, $2);}
Exp: Exp AND GenerateAndLabel Exp
    {$$ = Compiler::instance().pAnd(yylineno, $1, $3, $4);}
Exp: Exp OR GenerateOrLabel Exp
    {$$ = Compiler::instance().pOr(yylineno, $1, $3, $4);}
Exp: Exp EQUAL_UNEQUAL Exp
    {$$ = Compiler::instance().pRelOp(yylineno, $1, $2, $3);}
Exp: Exp INEQUALITY Exp
    {$$ = Compiler::instance().pRelOp(yylineno, $1, $2, $3);}



PushStatementScope: %empty
    {Compiler::instance().pAddStatScope(yylineno);}
PushWhileScope: %empty
    {Compiler::instance().pAddWhileScope(yylineno, $-3);}

PopScope: %empty
    {Compiler::instance().pRemoveScope(yylineno);}



CheckBool: %empty
    {Compiler::instance().pCheckBool(yylineno, $0);}


GenerateIfLabel: %empty
    {$$ = Compiler::instance().pGenerateIfL(yylineno);}
GenerateElseLabel: %empty
    {$$ = Compiler::instance().pGenerateElseL(yylineno);}
GenerateWhileHeadLabel: %empty
    {$$ = Compiler::instance().pGenerateWhileHeadL(yylineno);}
GenerateWhileBodyLabel: %empty
    {$$ = Compiler::instance().pGenerateWhileBodyL(yylineno);}
GenerateAndLabel: %empty
    {$$ = Compiler::instance().pGenerateAndL(yylineno);}
GenerateOrLabel: %empty
    {$$ = Compiler::instance().pGenerateOrL(yylineno);}
GenerateNextLabel: %empty
    {$$ = Compiler::instance().pGenerateNextL(yylineno);}


BNext: %empty
    {$$ = Compiler::instance().pBNext(yylineno);}
BWhileH: %empty
    {$$ = Compiler::instance().pBWhileH(yylineno);}
BIfNext: %empty
    {$$ = Compiler::instance().pBIfNext(yylineno);}




ConvertBool: %empty
    {$$ = Compiler::instance().pConvBool(yylineno, $0);}
%%

void yyerror(const char * message)
{
	errorSyn(yylineno);
	exit(0);
}